<!DOCTYPE html>
<html lang="fa" dir="rtl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ú†Øª Ø¢Ù†Ù„Ø§ÛŒÙ†</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
        }

        .chat-container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            min-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .chat-header {
            background-color: #4CAF50;
            color: white;
            padding: 15px;
            text-align: center;
        }

        .chat-messages {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            background-color: #e5ddd5;
        }

        .message {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 5px;
            max-width: 70%;
            clear: both;
        }

        .my-message {
            float: right;
            background-color: #dcf8c6;
            margin-left: 30%;
        }

        .other-message {
            float: left;
            background-color: #f1f1f1;
            margin-right: 30%;
        }

        .message .username {
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .message .text {
            word-wrap: break-word;
        }

        .chat-input {
            display: flex;
            padding: 15px;
            border-top: 1px solid #ddd;
            background-color: white;
        }

        #message-input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        #send-button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            margin-right: 10px;
            border-radius: 4px;
            cursor: pointer;
        }

        .call-controls {
            display: flex;
            gap: 10px;
        }

        #start-call,
        #end-call {
            background-color: #2196F3;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #end-call {
            background-color: #f44336;
            display: none;
        }

        #remote-audio {
            display: none;
        }

        .incoming-call {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            display: none;
        }

        .call-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .call-buttons button {
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #accept-call {
            background-color: #4CAF50;
            color: white;
        }

        #reject-call {
            background-color: #f44336;
            color: white;
        }
    </style>
</head>

<body>
    <div class="chat-container">
        <div class="chat-header">
            <h2 id="channel-title">Ú†Øª Ø¢Ù†Ù„Ø§ÛŒÙ†</h2>
        </div>
        <div class="chat-messages" id="chat-messages"></div>
        <div class="chat-input">
            <input type="text" id="message-input" placeholder="Ù¾ÛŒØ§Ù… Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ù†ÙˆÛŒØ³ÛŒØ¯...">
            <button id="send-button">Ø§Ø±Ø³Ø§Ù„</button>
            
            <div class="call-controls">
                <button id="start-call" title="Ø´Ø±ÙˆØ¹ ØªÙ…Ø§Ø³">ğŸ“</button>
                <button id="end-call" title="Ù¾Ø§ÛŒØ§Ù† ØªÙ…Ø§Ø³">âœ–ï¸</button>
            </div>
        </div>
    </div>

    <div class="incoming-call" id="incoming-call">
        <div id="caller-info">Ø¯Ø±ÛŒØ§ÙØª ØªÙ…Ø§Ø³ Ø§Ø² <span id="caller-name"></span></div>
        <div class="call-buttons">
            <button id="accept-call">Ù¾Ø°ÛŒØ±ÙØªÙ†</button>
            <button id="reject-call">Ø±Ø¯ Ú©Ø±Ø¯Ù†</button>
        </div>
    </div>

    <audio id="remote-audio" autoplay></audio>
    <audio id="ringtone" loop src="ringtone.mp3"></audio>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Ø¹Ù†Ø§ØµØ± DOM
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const chatMessages = document.getElementById('chat-messages');
        const startCallBtn = document.getElementById('start-call');
        const endCallBtn = document.getElementById('end-call');
        const incomingCallDiv = document.getElementById('incoming-call');
        const callerNameSpan = document.getElementById('caller-name');
        const acceptCallBtn = document.getElementById('accept-call');
        const rejectCallBtn = document.getElementById('reject-call');
        const remoteAudio = document.getElementById('remote-audio');
        const ringtone = document.getElementById('ringtone');
        const channelTitle = document.getElementById('channel-title');

        // Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ URL
        const urlParams = new URLSearchParams(window.location.search);
        const username = urlParams.get('username') || 'Ú©Ø§Ø±Ø¨Ø± Ù†Ø§Ø´Ù†Ø§Ø³';
        const channel = urlParams.get('channel') || 'Ø¹Ù…ÙˆÙ…ÛŒ';
        channelTitle.textContent = `Ú†Øª Ø¢Ù†Ù„Ø§ÛŒÙ† - Ú†Ù†Ù„ ${channel}`;

        // ÙˆØ¶Ø¹ÛŒØª ØªÙ…Ø§Ø³
        const callState = {
            isInCall: false,
            currentCall: null,
            peerConnection: null,
            localStream: null,
            pendingCandidates: []
        };

        // ØªÙ†Ø¸ÛŒÙ…Ø§Øª WebRTC
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // Ø§ØªØµØ§Ù„ Socket.io
        const socket = io();

        // Ù†Ù…Ø§ÛŒØ´ Ù¾ÛŒØ§Ù… Ø¯Ø± Ú†Øª
        function addMessage(data) {
            const isMyMessage = data.username === username;
            const messageElement = document.createElement('div');
            messageElement.className = isMyMessage ? 'message my-message' : 'message other-message';

            messageElement.innerHTML = `
                <div class="username">${data.username}</div>
                <div class="text">${data.text}</div>
            `;

            chatMessages.appendChild(messageElement);
            scrollToBottom();
        }

        // Ø§Ø³Ú©Ø±ÙˆÙ„ Ø¨Ù‡ Ù¾Ø§ÛŒÛŒÙ†
        function scrollToBottom() {
            setTimeout(() => {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }, 100);
        }

        // Ø¨Ù‡ Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª UI ØªÙ…Ø§Ø³
        function updateCallUI() {
            startCallBtn.style.display = callState.isInCall ? 'none' : 'flex';
            endCallBtn.style.display = callState.isInCall ? 'flex' : 'none';
        }

        // Ù¾Ø§ÛŒØ§Ù† ØªÙ…Ø§Ø³
        function endCall(initiatedLocally = true) {
            if (callState.isInCall) {
                if (initiatedLocally && callState.currentCall) {
                    socket.emit('endCall', { target: callState.currentCall });
                }

                // Ù‚Ø·Ø¹ Ø§ØªØµØ§Ù„Ø§Øª
                if (callState.peerConnection) {
                    callState.peerConnection.close();
                    callState.peerConnection = null;
                }

                // ØªÙˆÙ‚Ù Ø§Ø³ØªØ±ÛŒÙ…Ù‡Ø§
                if (callState.localStream) {
                    callState.localStream.getTracks().forEach(track => track.stop());
                    callState.localStream = null;
                }

                // Ø±ÛŒØ³Øª ÙˆØ¶Ø¹ÛŒØª
                callState.isInCall = false;
                callState.currentCall = null;
                callState.pendingCandidates = [];

                // Ø¨Ù‡ Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ UI
                updateCallUI();
                incomingCallDiv.style.display = 'none';
                remoteAudio.srcObject = null;
                ringtone.pause();
            }
        }

        // Ø´Ø±ÙˆØ¹ ØªÙ…Ø§Ø³ Ø¬Ø¯ÛŒØ¯
        async function startNewCall(targetUserId) {
            try {
                callState.isInCall = true;
                callState.currentCall = targetUserId;
                updateCallUI();

                // Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ù…ÛŒÚ©Ø±ÙˆÙÙˆÙ†
                callState.localStream = await navigator.mediaDevices.getUserMedia({ audio: true });

                // Ø§ÛŒØ¬Ø§Ø¯ Ø§ØªØµØ§Ù„ Peer
                callState.peerConnection = new RTCPeerConnection(rtcConfig);

                // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø§Ø³ØªØ±ÛŒÙ… Ù…Ø­Ù„ÛŒ
                callState.localStream.getTracks().forEach(track => {
                    callState.peerConnection.addTrack(track, callState.localStream);
                });

                // Ù…Ø¯ÛŒØ±ÛŒØª ICE Candidates
                callState.peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        socket.emit('candidate', {
                            target: callState.currentCall,
                            candidate: event.candidate
                        });
                    }
                };

                // Ø¯Ø±ÛŒØ§ÙØª Ø§Ø³ØªØ±ÛŒÙ… Ø±ÛŒÙ…ÙˆØª
                callState.peerConnection.ontrack = (event) => {
                    if (event.streams && event.streams[0]) {
                        remoteAudio.srcObject = event.streams[0];
                    }
                };

                // Ù…Ø¯ÛŒØ±ÛŒØª ØªØºÛŒÛŒØ± ÙˆØ¶Ø¹ÛŒØª Ø§ØªØµØ§Ù„
                callState.peerConnection.onconnectionstatechange = () => {
                    if (callState.peerConnection.connectionState === 'disconnected') {
                        endCall(false);
                        alert('ØªÙ…Ø§Ø³ Ù‚Ø·Ø¹ Ø´Ø¯');
                    }
                };

                // Ø§ÛŒØ¬Ø§Ø¯ Ùˆ Ø§Ø±Ø³Ø§Ù„ Offer
                const offer = await callState.peerConnection.createOffer();
                await callState.peerConnection.setLocalDescription(offer);

                socket.emit('offer', {
                    target: callState.currentCall,
                    offer: offer
                });

            } catch (error) {
                console.error('Ø®Ø·Ø§ Ø¯Ø± Ø´Ø±ÙˆØ¹ ØªÙ…Ø§Ø³:', error);
                endCall();
                alert('Ø®Ø·Ø§ Ø¯Ø± Ø´Ø±ÙˆØ¹ ØªÙ…Ø§Ø³: ' + error.message);
            }
        }

        // Ø¯Ø±ÛŒØ§ÙØª ØªÙ…Ø§Ø³ ÙˆØ±ÙˆØ¯ÛŒ
        async function acceptIncomingCall(offer) {
            try {
                // Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù…Ø¬ÙˆØ² Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ù…ÛŒÚ©Ø±ÙˆÙÙˆÙ†
                callState.localStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    },
                    video: false
                }).catch(err => {
                    console.error('Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ù…ÛŒÚ©Ø±ÙˆÙÙˆÙ†:', err);
                    throw new Error('Ø¨Ø±Ø§ÛŒ ØªÙ…Ø§Ø³ ØµÙˆØªÛŒ Ø¨Ø§ÛŒØ¯ Ø¨Ù‡ Ù…ÛŒÚ©Ø±ÙˆÙÙˆÙ† Ø¯Ø³ØªØ±Ø³ÛŒ Ø¯Ù‡ÛŒØ¯');
                });

                callState.isInCall = true;
                callState.currentCall = offer.sender;
                updateCallUI();
                incomingCallDiv.style.display = 'none';
                ringtone.pause();

                // Ø§ÛŒØ¬Ø§Ø¯ Ø§ØªØµØ§Ù„ Ø¬Ø¯ÛŒØ¯
                callState.peerConnection = new RTCPeerConnection(rtcConfig);

                // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø§Ø³ØªØ±ÛŒÙ… Ù…Ø­Ù„ÛŒ
                callState.localStream.getTracks().forEach(track => {
                    callState.peerConnection.addTrack(track, callState.localStream);
                });

                // Ù…Ø¯ÛŒØ±ÛŒØª Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§
                callState.peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        socket.emit('candidate', {
                            target: callState.currentCall,
                            candidate: event.candidate
                        });
                    }
                };

                callState.peerConnection.ontrack = (event) => {
                    if (event.streams[0]) {
                        remoteAudio.srcObject = event.streams[0];
                    }
                };

                callState.peerConnection.onconnectionstatechange = () => {
                    console.log('ÙˆØ¶Ø¹ÛŒØª Ø§ØªØµØ§Ù„:', callState.peerConnection.connectionState);
                };

                // ØªÙ†Ø¸ÛŒÙ… offer Ø¯Ø±ÛŒØ§ÙØªÛŒ
                await callState.peerConnection.setRemoteDescription(
                    new RTCSessionDescription(offer.offer)
                );

                // Ø§ÛŒØ¬Ø§Ø¯ Ùˆ Ø§Ø±Ø³Ø§Ù„ answer
                const answer = await callState.peerConnection.createAnswer();
                await callState.peerConnection.setLocalDescription(answer);

                socket.emit('answer', {
                    target: callState.currentCall,
                    answer: answer
                });

            } catch (error) {
                console.error('Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø°ÛŒØ±Ø´ ØªÙ…Ø§Ø³:', error);

                // Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø±Ø¯ ØªÙ…Ø§Ø³ Ø¨Ù‡ Ø·Ø±Ù Ù…Ù‚Ø§Ø¨Ù„
                if (offer && offer.sender) {
                    socket.emit('callRejected', { target: offer.sender });
                }

                // Ù†Ù…Ø§ÛŒØ´ Ù¾ÛŒØ§Ù… Ø®Ø·Ø§ Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø±
                let errorMessage = 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±Ù‚Ø±Ø§Ø±ÛŒ ØªÙ…Ø§Ø³';
                if (error.name === 'NotAllowedError') {
                    errorMessage = 'Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ù…ÛŒÚ©Ø±ÙˆÙÙˆÙ† Ø±Ø¯ Ø´Ø¯. Ù„Ø·ÙØ§Ù‹ Ù…Ø¬ÙˆØ²Ù‡Ø§ Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯.';
                } else if (error.message) {
                    errorMessage = error.message;
                }

                alert(errorMessage);
                endCall(false);
            }
        }

        // Ø´Ø±ÙˆØ¹ ØªÙ…Ø§Ø³ Ø¨Ø§ Ú©Ø§Ø±Ø¨Ø±
        async function startCall() {
            try {
                // Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø¬ÙˆØ²Ù‡Ø§ÛŒ Ø¯Ø³ØªØ±Ø³ÛŒ Ù‚Ø¨Ù„ Ø§Ø² Ø´Ø±ÙˆØ¹ ØªÙ…Ø§Ø³
                const permissionResult = await navigator.permissions.query({ name: 'microphone' });
                if (permissionResult.state === 'denied') {
                    throw new Error('Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ù…ÛŒÚ©Ø±ÙˆÙÙˆÙ† Ù…Ø³Ø¯ÙˆØ¯ Ø´Ø¯Ù‡ Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø±ÙˆØ±Ú¯Ø± Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯.');
                }
                const users = await new Promise(resolve => {
                    socket.emit('getUsersInChannel', channel, resolve);
                });

                if (!users.success || !users.users) {
                    throw new Error('Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒØ³Øª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†');
                }

                const otherUsers = users.users.filter(user => user.id !== socket.id);
                if (otherUsers.length === 0) {
                    throw new Error('Ù‡ÛŒÚ† Ú©Ø§Ø±Ø¨Ø± Ø¯ÛŒÚ¯Ø±ÛŒ Ø¯Ø± Ú†Ù†Ù„ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯');
                }

                // Ø´Ø±ÙˆØ¹ ØªÙ…Ø§Ø³ Ø¨Ø§ Ø§ÙˆÙ„ÛŒÙ† Ú©Ø§Ø±Ø¨Ø± Ù…ÙˆØ¬ÙˆØ¯
                await startNewCall(otherUsers[0].id);

            } catch (error) {
                console.error('Ø®Ø·Ø§ Ø¯Ø± Ø´Ø±ÙˆØ¹ ØªÙ…Ø§Ø³:', error);
                alert(error.message);
                endCall();
            }
        }

        // Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ Socket.io
        socket.on('connect', () => {
            socket.emit('joinChannel', { username, channel });
        });

        socket.on('message', addMessage);

        socket.on('offer', (offer) => {
            if (!callState.isInCall) {
                callerNameSpan.textContent = offer.username;
                incomingCallDiv.style.display = 'block';
                ringtone.play();
                window.currentOffer = offer;
            } else {
                socket.emit('callRejected', { target: offer.sender });
            }
        });

        socket.on('answer', async (answer) => {
            if (callState.peerConnection && callState.currentCall === answer.sender) {
                try {
                    await callState.peerConnection.setRemoteDescription(
                        new RTCSessionDescription(answer.answer)
                    );
                } catch (error) {
                    console.error('Ø®Ø·Ø§ Ø¯Ø± ØªÙ†Ø¸ÛŒÙ… Answer:', error);
                }
            }
        });

        socket.on('candidate', async (candidate) => {
            if (callState.peerConnection && callState.currentCall === candidate.sender) {
                try {
                    if (callState.peerConnection.remoteDescription) {
                        await callState.peerConnection.addIceCandidate(
                            new RTCIceCandidate(candidate.candidate)
                        );
                    } else {
                        callState.pendingCandidates.push(candidate.candidate);
                    }
                } catch (error) {
                    console.error('Ø®Ø·Ø§ Ø¯Ø± Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Candidate:', error);
                }
            }
        });

        socket.on('callRejected', () => {
            alert('ØªÙ…Ø§Ø³ Ø´Ù…Ø§ Ø±Ø¯ Ø´Ø¯');
            endCall();
        });

        socket.on('callEnded', () => {
            alert('ØªÙ…Ø§Ø³ ØªÙˆØ³Ø· Ø·Ø±Ù Ù…Ù‚Ø§Ø¨Ù„ Ù‚Ø·Ø¹ Ø´Ø¯');
            endCall(false);
        });

        // Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§
        sendButton.addEventListener('click', () => {
            const message = messageInput.value.trim();
            if (message) {
                socket.emit('sendMessage', message);
                messageInput.value = '';
            }
        });

        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendButton.click();
            }
        });

        startCallBtn.addEventListener('click', startCall);
        endCallBtn.addEventListener('click', () => endCall(true));
        acceptCallBtn.addEventListener('click', () => acceptIncomingCall(window.currentOffer));
        rejectCallBtn.addEventListener('click', () => {
            socket.emit('callRejected', { target: window.currentOffer.sender });
            incomingCallDiv.style.display = 'none';
            ringtone.pause();
        });

        // Ù…Ø¯ÛŒØ±ÛŒØª Ø¨Ø³ØªÙ‡ Ø´Ø¯Ù† ØµÙØ­Ù‡
        window.addEventListener('beforeunload', () => {
            if (callState.isInCall) {
                endCall(true);
            }
        });
    </script>
</body>

</html>